# 네트워크 및 DB 질문

기본적으로는 [신입 개발자 면접 질문 시리즈](https://www.notion.so/54d624628a634c879cc93d94f54cd2d1)에서 답변을 가지고 왔습니다.

<br>

### `www.naver.com`을 치면?

>링크 : https://www.notion.so/www-naver-com-2f8167ca73ed41fbaac9bb95b262238f

<br>

### HTTP와 HTTPS에 차이와 HTTPS에서 S는 어떤 계층에 속했는지 설명하시오.

#### HTTP와 HTTPS의 차이

- HTTPS란?
  - HTTP + S(Over Secure Socket Layer)로, 기존 HTTP의 문제점을 보완하기 위해 탄생한 통신규약, HTTP의 하부에 SSL과 같은 보안계층을 제공
- HTTP의 문제점
  - 텍스트 교환 중, 기밀사항(비밀번호 등)의 감청 및 변조가 가능하였다.(보안상의 문제)

![](https://github.com/conquerex/OneHundredMillionSalary/blob/master/3_NWandDB/image_nw_1.png?raw=true)

SSL﻿프로토콜은 OSI 7계층 모델의 어느 한 계층에 속해서 동작하는 것이 아니라, 응용계층과 전송계층 사이에 독립적인 프로토콜 계층을 만들어서 동작하며,이 때, 응용계층의 프로토콜들은 외부로 보내는 데이터를 TCP가 아닌 SSL에 보내게 되고, SSL은 받은 데이터를 암호화하여 TCP에 보내어 외부 인터넷으로 전달하게 됩니다.

![](https://github.com/conquerex/OneHundredMillionSalary/blob/master/3_NWandDB/image_nw_2.png?raw=true)

> 참고 링크
- https://wayhome25.github.io/cs/2018/03/11/ssl-https/
- https://opentutorials.org/course/228/4894
- https://m.blog.naver.com/xcripts/70122755291
- 하트블리드 취햑점은 별도로 알아보세요.  (by 종국)

<br>

### get방식과 post방식 그리고 CRUD에 대해 설명해주세요.
##### 부제 : HTTP Method에 대해 설명해주세요.

| Method | 설명 |
| :--------: |:---------------|
|POST (Create)|서버 측에 데이터를 전송하여, 생성(Create)을 요청한다. <br>새로 작성된 리소스인 경우 헤더의 Location 필드에 URI주소를 포함하여 응답한다.|
|GET (Read)|서버 측에 필요한 데이터를 요청(Read)한다.|
|PUT (Update)|서버에 존재하는 데이터를 수정(Update)한다.<br>요청데이터가 존재하지 않는 경우에는 생성한다. <br><br>- POST와의 차이점 :<br>헤더의 Location 필드에 URI주소를 포함하지 않는다.<br>클라이언트는 요청 URI를 그대로 사용하는 것으로 간주하기 때문|
|PATCH (Update)|서버에 존재하는 데이터를 수정(Update)한다.<br><br>* PUT과의 차이점 :<br>PUT은 데이터를 전체 수정하지만 PATCH는 데이터의 일부만 수정한다.|
|DELETE (Delete)|서버에 존재하는 데이터를 삭제(Delete)한다.<br>안정성 문제로 현재 대부분의 서버에서 비활성화되어 있다.<br>(HTTP 규격에는 Client의 요청에도 서버가 무효화 시킬수 있도록 정의되어 있음)|
|HEAD|서버 측에 필요한 데이터를 요청한다.<br><br>* GET과의 차이점 :<br>Response Body가 없다.<br>(데이터 존재여부, 수정날짜 확인 등으로만 사용)|
|CONNECT|요청한 리소스에 대해 양방향(터널) 연결을 시작한다.<br>Client가 Proxy를 통해서 Server와 SSL통신을 하고자 할 때 사용된다.|
|TRACE|서버로 전송한 데이터 재확인(변조여부 확인)을 위해 테스트용으로 사용한다.|
|OPTIONS|서버에서 지원하는 HTTP Method 종류를 확인한다.|

>참고 링크
- https://papababo.tistory.com/269
- https://medium.com/@lyhlg0201/http-method-d561b77df7
- https://javaplant.tistory.com/18
- https://developer.mozilla.org/ko/docs/Web/HTTP/Methods/CONNECT
- https://dinding.tistory.com/41

<br>

#### 트랜스포트 계층과 TCP/UDP
인터넷 네트워크에서, TCP와 UDP는 트랜스포트 계층의 프로토콜(protocol) 입니다.  여기서 트랜스포트 계층 (Transport layer)과 프로토콜이 무엇일까요?

##### 프로토콜 (Protocol)

프로토콜은 둘 이상의 통신 개체 간에 교환되는 메시지 형식과 순서뿐 아니라, 메시지의 송수신과 기타 이벤트등에 따른 행동들을 정의한다.

아직 잘 감이 오지 않는다면, 사람과의 비교를 통해 이해해보도록 합시다.
사람은 항상 프로토콜을 수행하므로 사람의 경우와 비교하면 컴퓨터 네트워크 프로토콜 개념을 가장 쉽게 이해할 수 있습니다. 사람의 프로토콜(바른 예절 대화 프로토콜)에서 상대방과 의사소통하기 위해 먼저 ‘인사’를 합니다.

`“안녕”`

이 “안녕”이라는 인사에대한 일반적 응답은 역시, “안녕” 입니다.

처음 인사를 건넨 사람은 상대방의 “안녕” 응답을 통해 상대방이 자신과 대화할 의사가 있다고 판단하고 계속 대화를 이어 나갑니다. 처음 인사에 부정적인 반응 (무시 , “꺼져” 등등..) 은 상대방이 의사소통을 거부하거나 대화할 수 없음을 나타낸다고 볼 수 있습니다. 사람 프로토콜에서, 우리가 보내는 특정한 메시지가 있고, 수신된 응답 메시지 혹은 다른 상황에 대응해서 취하는 특정한 행동이 있습니다.

사람 프로토콜에서  서로 이해하지 못하는 메시지나 응답을 보낸다면, 예를 들어 다른 나라의 언어를 사용해서 대화하려 한다면, 그 프로토콜은 상호작용할 수 없으며 원하는 작업을 수행할 수 없습니다. 네트워킹도 마찬가지 입니다. 어떤 일을 수행하기위해 둘 이상의 통신 개체가 함께 인식하는 프로토콜이 필요합니다. 프로토콜에 대해서 어느정도 감이 왔다면 프로토콜 계층에 대해 알아봅시다.

##### 프로토콜 계층
인터넷은 매우 복잡하고 이해하기 어려운 시스템이기 때문에 적절한 비유를 들어가면서 이해하면 좋습니다.

항공 시스템을 떠올려 봅시다. 티켓 에이전트, 수하물 검색대, 탑승구 요원, 비행기, 관제소, 비행기를 라우탕하는 복잡한 시스템,,  여기서 전체적인 항공 시스템의 구조를 어떻게 찾을 수 있을까요?

한 가지 방법으로, 일련의 행동들을 설명하는 방법이 있습니다.

여러분들이 비행기 티켓을 사고, 가방을 검사받고, 탑승구로 가고, 비행기에 타면, 비행기는 이륙하고 목적지로 향합니다. 착륙 후, 탑승구를 통해 내리고 짐을 찾습니다. 여행이 불편했다면 티켓 에이전트에게 항의합니다.

여기서 컴퓨터 네트워킹과 유사한 구조를 찾을 수 있습니다.

![](https://github.com/conquerex/OneHundredMillionSalary/blob/master/3_NWandDB/image_nw_3.png?raw=true)

항공 시스템 기능을 계층으로 나누었습니다. 각 계층은 아래 계층과 연계하여 어떤 기능, 서비스를 구현합니다. 티켓팅 계층과 그 아래에서는 항공사 카운터 간에 사람의 전송이 이루어집니다. 수하물 계층과 그 아래에서는 수하물 창구사이에서 사람과 수하물의 전송이 이루어집니다.

각 계층은  그 계층에서 어떤 동작을 취하고 ( 탑승구 계층에서 비행기에 사람을 오르내리게 하는 것)

그 계층 바로 아래 계층 서비스를 이용함으로써 ( 탑승구 계층에서 이착륙 계층의 활주로를 이용하여 승객을 이동시키는 것) 자신의 계층의 서비스를 제공합니다.

한 계층이 상위 계층에 같은 서비스를 제공하고 하위 계층의 서비스를 이용하는 한, 어떤 한 계층의 구현이 변하더라도 시스템의 나머지 부분은 변하지 않습니다.

예를 들어 탑승구 기능이 변하면(키 순서대로 타고 내리게 한다면), 탑승구 계층은 아직 같은 기능, 사람을 싣고 내리는 것, 을 제공하므로 항공 시스템의 나머지는 변하지 않지요.

이제 네트워크 프로토콜로 시선을 옮겨 봅시다.
네트워크 설계자는 프로토콜(프로토콜을 구현하는 네트워크 하드웨어와 소프트웨어) 를 계층으로 조직합니다.


![](https://github.com/conquerex/OneHundredMillionSalary/blob/master/3_NWandDB/image_nw_4.png?raw=true)

항공사 시스템처럼 각 계층은  그 계층 내부에서 어떤 동작을 수행하거나,  직접 하위 계층의 서비스를 이용합니다.

항공사 시스템에서는 계층 사이에 사람이 운반되어졌지만, 네트워크에서는 패킷(데이터)가 운반되어집니다. 그리고 각 계층 별로 프로토콜이 존재합니다.

모든 계층을 자세히 다루기에는 끝이 없기 때문에 TCP/UDP가 속한 트랜스포트 계층에 초점을 맞추도록 하겠습니다.

##### 트랜스포트 계층

인터넷의 트랜스포트 계층은 클라이언트와 서버 간에 애플리케이션 계층 메시지를 전송하는 서비스를 제공합니다.

여기서 메시지는 패킷을 뜻합니다. 패킷은 전송하려고하는 데이터의 조각으로 볼 수 있습니다. 이 패킷을 애플리케이션 계층에서 메시지라고 부릅니다. 각 계층별로 패킷을 뜻하는 명칭이 다릅니다. 트랜스포트 계층에서는 세그먼트라고 부릅니다.

인터넷에는 두 가지, 즉 TCP와 UDP라는 트랜스포트 프로토콜이 있습니다. 이들은 애플리케이션 계층 메시지를 세그먼트로 캡슐화하여 네트워크 계층으로 전달합니다.

##### 캡슐화/역캡슐화 (encapsulation / decapsulation)

각 계층에서 패킷에 사용될 추가 정보들을 더 하는 것, 정도로 이해하면 되겠습니다.
트랜스포트 계층에서는 어떤 추가 정보들이 더 해질까요? 적절한 애플리케이션으로 보내도록 하는 정보와 메시지의 비트들이 변경되었는지 아닌지를 수신자가 알게하는 오류 검출 비트 등등을 더 해줍니다. 이 과정을 캡슐화라고 합니다.

즉,  메시지 +  트랜스포트 계층 추가정보 (헤더정보) = 세그먼트
이런 관계라고 할 수 있습니다.

역캡슐화는 이와 반대로, 하위 계층에서 패킷을 받았을 때 하위 계층에서 추가한 정보들을 떼어내는 작업을 말합니다. 다시 돌아와서, 트랜스포트 계층 프로토콜은 서로 다른 호스트에서 동작하는 애플리케이션 프로세스들 간의 논리적 통신을 제공합니다. 논리적 통신은 서로 통신하는 프로세스들이 직접 연결된 것 처럼 보인다는 것을 의미합니다. 실제로 프로세스들은 지구상의 서로 다른 지역에 있을 수 있습니다.

이번에도 비유를 해보겠습니다.
두 집안이 있습니다. 하나는 미국에 있고 하나는 한국에 있습니다. 그리고 집안마다 12명의 아이들이 있습니다. 미국 집안의 아이들과 한국 집안의 아이들은 사촌지간입니다. 두 집안의 아이들은 서로 편지 쓰기를 좋아합니다. 두 집안에는 각각 우편을 수거하고 나눠 주는 한 명의 아이가 있는데, 미국 집안은 “존”  한국 집안은 “김”이 담당합니다.

매주 존은 모든 형제자매의 우편물을 수거하고, 집배원에게 우편물을 전달합니다. 편지가 집에 도착하면 존은 또한 그 편지들을 나눠 주는 일을 합니다. 한국의 김도 마찬가지 일을 합니다.

이 예시에서, 우편 서비스는 두 집 간에 논리 통신을 제공합니다. 우편 서비스는 우편물을 개인으로부터 개인에게로 이동시키는 것이 아니라, 집에서 집으로만 이동 시킵니다.
반면에, 존과 김은 사촌 형제들 사이에서 논리 통신을 제공합니다. ( 존과 김은 사촌 형제로부터 우편물을 받아서 형제와 자매들에게 전달한다)  

>- 애플리케이션 메시지  =   편지
- 프로세스 =  사촌 형제
- 호스트(한 종단 시스템)  =  집
- 트랜스포트 계층 프로토콜  =   존 과 김
- 네트워크 계층 프로토콜  =  우편 서비스(우편 집배원 포함)

존과 김은 본인 집에서만 일할 뿐이고 우편물을 배송하는 일에는 참여하지 않습니다. 즉 트랜스포트 계층 프로토콜은 종단 시스템에 존재하고 네트워크 계층 내부에서 메시지가 어떻게 이동하는지는 언급하지 않습니다.

실제로 라우터는 트랜스포트 계층이 애플리케이션 메시지에 추가한 어떤 정보도 인식하지 못하며, 그 정보에 영향을 주지도 않습니다.

존과 김이 제공할 수 있는 서비스는 우편 서비스가 제공할 수 있는 서비스에 따라 제한됩니다. 예를 들어, 우편 서비스가 두 집 사이에서 우편물이 배달되는 데 특정한 기간을 보장하지 않는다면 ( 한달이 걸릴 수도 있다면 )  ,  존과 김이 사촌들에게 우편물 배달에 대한 최대 지연을 보장할 수 있는 방법은 없습니다.

마찬가지로, 트랜스포트 계층이 제공할 수 있는 서비스는 하위 네트워크 계층 프로토콜에 의해서 제약받습니다.

그럼에도 불구하고 하위 네트워크 프로토콜이 상응하는 서비스를 제공하지 못할 때에도 , 특정 서비스는 트랜스포트 프로토콜에 의해서 제공될 수 있습니다.

예를 들어, 네트워크 프로토콜이 비신뢰적( 패킷을 분실하거나 손상시킬 수 있음)일 때에도 애플리케이션에게 신뢰적인 데이터 전송 서비스를 제공할 수 있습니다.

##### TCP / UDP
자 이제 드디어, TCP와 UDP에 대해서 얘기할 수 있을 것 같습니다. TCP와 UDP의 가장 기본적인 기능은 종단 시스템 사이의 IP 전달 서비스를 종단 시스템에서 동작하는 두 프로세스 간의 전달 서비스로 확장하는 것 입니다.

쉽게 말하자면, 네트워크 계층에서 받은 패킷을 목적지 프로세스에게 전달하는 역할입니다. 즉 , 호스트 - 호스트 전달을 프로세스 - 프로세스 전달로 확장하는 것 입니다. 이것을 `트랜스포트 다중화(transport multiplexing)`, `역다중화(demultiplexing)`라고 부릅니다.

프로세스는 소켓을 가지고 있습니다. 데이터의 출입구 정도로 생각해주시면 되겠습니다. 이를 통해 네트워크에서 프로세스로 데이터를 전달하게 됩니다. 트랜스포트 계층은 실제로 데이터를 직접 프로세스로 전달하지 않고 소켓에게 전달합니다. 각각의 소켓은 유일한 식별자 (포트 번호) 를 가지고, 이 식별자의 포맷은 UDP 소켓인지 TCP 소켓인지에 따라 달라집니다.

트랜스포트 계층 세그먼트의 데이터를 올바른 소켓으로 전달하는 작업을 역다중화, 이와 반대로 출발지 호스트에서 소켓으로부터 데이터를 모으고 , 이에 대한 세그먼트를 생성하기 위해서 각 데이터에 헤더 정보를 붙이고 그 세그먼트들을 네트워크 계층으로 전달하는 작업을 다중화라고 합니다.

존과 김이 우편집배원으로부터 우편 한 묶음을 받았을 떄,  우편물이 누구에게 온 것인지 보고 그 형제자매에게 직접 전달하는 것이 역다중화, 형제 자매들의 우편물을 모으고 집배원에게 전달하는 작업이 다중화라고 할 수 있겠습니다.

UDP의 경우, 소켓은 목적지 IP 주소와 목적지 포트 번호로 식별됩니다. 만약 2개의 UDP 세그먼트들이 출발지 IP, 출발지 포트번호가 다르더라도 , 동일한 목적지 IP 주소와 동일한 목적지 포트 번호를 가지면 2개의 세그먼트들은 같은 소켓에 전달됩니다.

TCP의 경우, 소켓은 출발지 IP 주소, 출발지 포트 번호, 목적지 IP주소, 목적지 포트 번호  총 4개 요소들에 의해 식별됩니다. 이 4개 요소가 같다면 같은 소켓으로 전달되고 하나만 다르더라도 다른 소켓으로 전달됩니다.

TCP/UDP의 또 다른 차이점으로는, UDP는 애플리케이션 계층에서 메시지를 받자마자 UDP세그먼트로 만들고, 즉시 그 세그먼트를 네트워크 계층으로 전달합니다.

이에 반해서 TCP는 혼잡제어 메커니즘이란 것을 가지고 있습니다. 이 혼잡제어 메커니즘은 목적지 호스트들과 출발지 호스트들 사이에서 하나 이상의 링크(데이터가 오고 가는 통로)가 과도하게 혼잡해지면, 트랜스포트 계층 TCP 송신자를 조절하는 역할을 합니다.

또한 TCP는 신뢰적인 전달이 얼마나 오래 걸리는지에 관계없이 목적지가 세그먼트의 수신 여부를 확인응답할 때까지 데이터를 재전송합니다.

따라서 실시간 애플리케이션(실시간 동영상 스트리밍, 전화 등등)은 지나치게 지연되는 세그먼트 전송을 원하지 않으며,  조금의 데이터 손실은 허용할 수 있기때문에 UDP를 사용합니다.

반면에 신뢰성이 중요한 문서 전달, 파일 전송 애플리케이션은 TCP를 이용합니다.
UDP는 연결설정이 없습니다. TCP는 데이터 전송을 시작하기 전에 세방향 핸드셰이크를 사용합니다. 반면에 UDP는 형식적인 예비동작 없이 전송합니다. 그러므로 UDP는 연결을 설정하기 위한 어떤 지연도 없게 됩니다.

또한 UDP는 연결 상태가 없습니다. TCP는 종단 시스템에서 연결 상태를 유지합니다. 이 연결 상태는 수신 버퍼 및 송신 버퍼, 혼잡제어에 필요한 파라미터 등등을 포함합니다. 상태 정보들은 TCP의 신뢰적인 데이터 전송 서비스를 구현하고 혼잡제어를 제공하기 위해서 필요합니다.

반면에 UDP는 연결 상태를 유지하지 않으며 이 파라미터 중의 어떤 것도 기록하지 않습니다. 그래서 일반적으로 특정 애플리케이션에 할당된 서버는 애플리케이션이 TCP보다 UDP에서 동작할 때 좀 더 많은 클라이언트를 수용할 수 있습니다.

마지막으로, TCP가 세그먼트마다 20바이트의 헤더 오버헤드를 갖는 반면에 UDP는 단지 8바이트의 오버헤드를 가집니다.

##### UDP 세그먼트 구조

![](https://github.com/conquerex/OneHundredMillionSalary/blob/master/3_NWandDB/image_nw_5.png?raw=true)

UDP 헤더는 2바이트씩 구성된 4개의 필드 , 출발지 포트번호, 목적지 포트 번호, 길이, 체크섬 필드를 가집니다.
체크섬은 오류 검출 비트인데 궁금하신 분들은 구글에 검색하면 됩니다. 여기서는 생략하겠습니다.

##### TCP 세그먼트 구조

![](https://github.com/conquerex/OneHundredMillionSalary/blob/master/3_NWandDB/image_nw_6.png?raw=true)

매우 복잡하므로 생략하겠습니다.

>참고 문헌
James F. Kurose , Keith W. Ross   -  Computer NetWorking A Top-Down Approach 7th

<br>

### REST와 SOAP에 대해 설명하시오.

REST API란? **REST(Representational State Transfer)**는 네트워크를 통해서 컴퓨터들끼리 통신할 수 있게 해주는 `아키텍처` 스타일입니다.

REST API는 **인터넷 식별자(URI)와 HTTP 프로토콜을 기반**으로 합니다. REST는 **HTTP 프로토콜 덕분에 ‘단순함’이 핵심**이라고 할 수 있습니다. **데이터 포맷으로는 브라우저 간 호환성이 좋은 제이슨(JSON)을 사용**합니다. REST API는 구축과 확장이 간단하지만, 크고 복잡하게 만들 수도 있습니다. 이는 API를 어떻게 만들고, 무엇을 추가하고, 어떤 목적으로 설계되었는지에 따라 달려있습니다.

REST API는 클라이언트와 서버 사이에서 통신할 수 있게 하고, 아키텍처를 만들 수 있게 해줍니다. **REST 방식의 API라면, 클라이언트-서버 모델로 구축되었다는 것을 의미**하며, 정보의 페이로드(실제 전달하려는 내용)가 두 지점 사이를 왕복하게 됩니다.

REST API는 **단일한 인터페이스**를 사용합니다. 이러한 점 때문에 해당 API를 사용하는 애플리케이션들이 동일한 경로를 통해서 접속해야 하고, 그 방식이 단순하게 됩니다. 여기에는 장점도 있고, 단점도 있기 때문에 향후 개발 과정에서 어떤 영향이 있는지에 대해서 알고 싶다면 전문가와 상의해보는 것이 좋습니다.

REST는 **웹에 최적화**되어 있고, 데이터 포맷이 JSON이기 때문에 **브라우저들 간에 호환성**이 좋습니다. 또한, 그 성능과 확장성이 뛰어난 것으로도 알려져 있죠. 하지만 다른 기술들과 마찬가지로 그 자체의 기능이 정지되거나 여러분의 앱을 먹통으로 만들 수도 있습니다. 그래서 REST로는 풀지 못하는 문제들을 해결하기 위해서 그래프QL과 같은 언어가 생겨난 것입니다.

##### SOAP API란?
**SOAP(Simple Object Access Protocol)**는 그 자체로 `프로토콜`이며, 보안이나 메시지 전송 등에 있어서 **REST보다 더 많은 표준들이 정해져있기 때문에 조금 더 복잡**합니다. 이러한 표준들로 인해서 오버헤드가 많기는 하지만, **보안, 트랜잭션, ACID(원자성, 일관성, 고립성, 지속성)을 준수해야 하는 보다 종합적인 기능이 필요한 조직**에게는 적합한 방식이 될 수 있습니다. 굳이 비교를 하자면, SOAP는 웹 서비스 시나리오에 적용하기에는 그다지 좋지 않기 때문에, **기업용 애플리케이션** 등을 작업하는데 더 이상적이라고 말할 수 있습니다.

SOAP는 **보안 수준이 엄격**합니다. SOAP에서는 SSL도 지원하고 WS-Security라는 자체 표준의 보안 기능도 가지고 있지요. 따라서 은행용 모바일 앱처럼 보안 수준이 높아야 하거나, 신뢰할 수 있는 메시징 앱, 또는 ACID를 준수해야 하는 경우라면 SOAP 방식이 더욱 선호됩니다.

REST에서는 표준화된 메시징 시스템이 갖춰져 있지 않으며, 통신 장애가 있을 경우 재시도를 통해서만 조치할 수 있습니다. 반면 SOAP 표준에는 성공/반복 실행 로직이 규정되어 있기 때문에, **SOAP API를 통해서 통신을 할 때 처음부터 끝까지 신뢰성을 제공합니다.**

SOAP 표준에는 ACID 준수에 관한 사항이 있습니다. ACID를 준수하기 때문에 데이터의 변형을 줄여주고, 데이터베이스와의 상호작용에 대해서 사전에 정확하게 정하기 때문에 데이터의 무결성을 지켜주지요. ACID는 데이터 일관성을 위한 다른 방식들보다도 더 보수적이기 때문에, 금융 정보 등의 민감한 데이터를 주고받을 때 일반적으로 많이 사용됩니다.

![](https://github.com/conquerex/OneHundredMillionSalary/blob/master/3_NWandDB/image_nw_7.png?raw=true)

- 그 외 특징
  - REST는 HTTP와 JSON을 사용하기 때문에 페이로드의 무게를 가볍게 할 수 있습니다. 하지만 SOAP에서는 XML에만 의존합니다.

>참고 링크
- http://blog.wishket.com/soap-api-vs-rest-api-%EB%91%90-%EB%B0%A9%EC%8B%9D%EC%9D%98-%EA%B0%80%EC%9E%A5-%ED%81%B0-%EC%B0%A8%EC%9D%B4%EC%A0%90%EC%9D%80/

<br>

### Restful 하지 않다는 것은 무슨 의미인가요?
- Restful
  - REST API의 설계 의도를 명확하게 지켜주는 것
  - 각 구성요소들의 역할이 완벽하게 분리되어 있는 것
- URI의 명확한 정의
  - REST API를 사용함으로써 메소드는 반 강제적으로 Uniform 하게 제공되지만, 실무에서 자율성이 가장 크게 반영되는 URI의 설계의 경우는 다릅니다.

##### REST API 설계 규칙

1. 슬래시(/)를 통한 계층 관계 표시
2. 자원에 대한 행위는 HTTP METHOD로 표현한다.
3. 파일 확장자는 URI에 미포함
4. 명사 위주의 URI
5. 그 외 여러개...

위와 같은 규칙이 적용되지 않으면 "Restful 하지 않다"라고 할 수 있다.

> 참고 링크
- https://velog.io/@stampid/REST-API%EC%99%80-RESTful-API
- https://wallees.wordpress.com/2018/04/19/rest-api-restful/

<br>

### 쿠키와 세션에 대해 설명해주세요.
- HTTP(Hypertext Transfer Protocol)
  - 브라우저 같은 응용 프로그램을 통해 사용자와 서버 사이에 전송하는 프로토콜이다.
  - HTTP는 연결 상태를 유지하지 않는 비연결적인 프로토콜이라는 특징을 가지고 있다.
  - 예를 들어 브라우저를 통해 사용자의 요청에 따라 서버에 접속하여 요청에 대한 응답의 데이터를 전송 한 뒤에 연결을 종료한다.

이런 간단한 과정 덕택에 전산 자원이 적게 든다는 장점이 있지만 연결이 지속적이지 않기 때문에 **사용자와 연결을 종료한 뒤에 추가적으로 요청을 처리할 수 없다는 단점**이 있다. 만약 단순 http 연결만으로 사이트를 구성한다면 상품 등을 구매할때 로그인 정보가 계속 연결되지 않아서 매번 구매를 할 때마다 로그인 창이 뜨는 일이 생길 수도 있다. 이런 단점들을 해결하기 위해 쿠키나 세션과도 같은 방법들이 사용되는 것이다.

현재 우리가 인터넷에서 사용하고 있는 HTTP프로토콜은 연결 지향적인 성격을 버렸기 때문에 새로운 페이지를 요청할 때마다 새로운 접속이 이루어지며 이전 페이지와 현재 페이지 간의 관계가 지속되지 않는다. 이에 따라 HTTP프로토콜을 이용하게 되는 웹사이트에서는 웹페이지에 특정 방문자가 머무르고 있는 동안에 그 방문자의 상태를 지속시키기 위해 쿠키와 세션을 이용한다.

우선적으로 쿠키와 세션을 자세히 알아보기 전에 가장 큰 특징 먼저 잡고 가자면 **쿠키는 클라이언트(로컬, 사용자)쪽에서 저장하는 정보들을 말하고, 세션은 서버(정보 제공자)에 저장한다**는 큰 틀을 잡고 가면 좋다.

- 쿠키(Cookie)
  - 쿠키는 사용자의 브라우저에 저장이 되기 때문에 서버의 자원을 사용할 수 없고, 사용자의 컴퓨터만 있다면 누구나 쿠키안에 있는 데이터를 확인할 수 있기 때문에 보안성이 떨어진다.
  - Cookie는 인터넷 사용자가 특정 웹서버에 접속할 때, 생성되는 개인 아이디와 비밀번호, 방문한 사이트의 정보를 담은 임시 파일로써, Server가 아닌 Client에 텍스트 파일로 저장되어 다음에 해당 웹서버를 찾을 경우 웹서버에서는 그가 누구인지 어떤 정보를 주로 찾았는지 등을 파악할 때 사용된다.
  - 사용자 정보를 유지할 수 없다는 HTTP의 한계를 극복할 수 있는 방법
  - 인터넷 웹 사이트의 방문 기록을 남겨 사용자와 웹 사이트 사이를 매개해 주는 정보이다.
  - Cookie는 Client PC에 저장되는 정보기 때문에, 다른 사용자에 의해서 임의로 변경이 가능하다.(정보 유출 가능, Session보다 보안성이 낮은 이유)
- 세션(Session)
  - 클라이언트와 웹 서버간에 네트워크 연결이 지속적으로 유지되고 있는 상태.
  - 서버에 데이터를 저장해 서버의 자원을 사용할 수 있으며 클라이언트가 페이지를 이동 하거나, 재접속했을 때 구분할 수 있는 수단.
  - 서버에 접속하지 않는 이상 데이터를 탈취하기 어렵기 때문에 중요한 데이터를 저장할 때 주로 사용된다.
  - 특정 웹사이트에서 사용자가 머무르는 기간 또는 한 명의 사용자의 한번의 방문을 의미한다.
  - Session에 관련된 데이터는 Server에 저장된다.
  - 웹 브라우저의 캐시에 저장되어 브라우저가 닫히거나 서버에서 삭제시 사라진다.
  - Cookie에 비해 보안성이 좋다.
  - 주로 로그인 정보 유지하는 것에 사용된다.
- 뽀나스 - 캐시(Cache)
  - 데이터나 값을 미리 복사해 임시로 저장해두는 장소를 말한다.
  - 예를 들어 사이트를 불러올때 전에 불러왔던 사진이나 배너, css,js 등을 접속 할 때마다 불러오게 된다면 데이터의 낭비가 일어나게 된다 이를 방지하기 위해서 미리 클라이언트에 저장해두고 다시 접속했을 때 서버가 아닌 사용자의 PC에서 이를 가져오게 되므로 용량을 아낄 수 있다.
  - 캐시를 비우지 않으면 관리자가 이미지를 변경할 경우 사용자의 이미지는 변경되어있지 않는 등의 일이 생길 수 있다.

<br>

### RDBMS와 NoSQL의 차이는?

- **RDBMS**
  - SQL은 Structured Query Language의 약자로 데이터베이스에서 사용하는 쿼리 언어 입니다. SQL을 사용하여 RDBMS에서 데이터를 검색, 저장, 수정, 삭제 등이 가능합니다.
  - RDBMS는 Relational Database Management System으로 말 그대로 관계형 데이터베이스 관리 시스템입니다. RDBMS는 정해져있는 데이터 스키마에 따라 데이터베이스 테이블에 저장되며, 관계를 통한 테이블간 연결을 통해 사용됩니다. 이 때문에 RDBMS는 데이터 관리를 효율적으로 하기위해 구조화가 굉장히 중요합니다.
  - 오라클, MySQL, IBM DB2, PostgreSQL
- 스키마
  - 데이터베이스를 구성하는 데이터 개체(Entity), 속성(Attribute), 관계(Relationship) 및 데이터 조작 시 데이터 값들이 갖는 제약 조건 등에 관해 전반적으로 정의한다.
- RDBMS 장점
  - 정해진 스키마에 따라 데이터를 저장하여야 하기 때문에 명확한 데이터 구조를 보장합니다. (데이터 무결)
  - 각 데이터에 맞게 테이블을 나누어 데이터 중복을 피해 데이터 공간을 절약 할 수 있습니다.
- RDBMS 단점
  - Oracle 같은 시스템을 사용하게 될 경우 비용적으로 부담이 될 수 있습니다.
  - RDBMS 관계로 인한 시스템 복잡도를 고려하여 구조화를 해야합니다. 시스템이 복잡해 질수록 Query문이 복잡해지고 성능이 저하됩니다.
  - 수평적확장이 어려워 수직적 확장을 대부분 하기 때문에 한계에 직면할 수 있습니다.
- **NOSQL**
  - Not Only SQL, Non relational Database라고 부른다고 합니다. NOSQL은 관계형 데이터베이스와 반대되는 방식을 사용하여 스키마와 관계라는 개념이 없습니다.
  - RDBMS에서는 스키마에 맞추어 데이터를 관리하여야 하지만 NOSQL은 스키마가 없어 좀 더 자유롭게 데이터를 관리할 수 있습니다.
  - NOSQL에서 테이블과 같은 개념으로 컬렉션이라는 형태로 데이터를 관리합니다.
- NOSQL 장점
  - 정해진 스키마에 따라 저장해야하는 RDBMS 보다 자유롭게 데이터를 추가가 가능합니다. 이는 복잡한 테이블간의 관계를 형성하는 형태의 구조를 신경쓰지 않아도 됩니다. 예로는 조인 등 복잡한 SQL구문으로 인한 문제가 있겠습니다.
  - NOSQL에서는 필요한 데이터가 보통 하나의 컬렉션에 있으며, 이는 자주 변경되지 않는 데이터에 큰 장점이 있다고 합니다.
  - 수평적 확장이 어려운 RDBMS보다는 수평적 확장이 쉽다는 점
  - NOSQL은 분산처리 목적으로 나왔기 때문에 프레임워크에서 분산처리 기능을 포함하고 있다고 합니다.
- NOSQL 단점
  - 자유롭게 데이터가 추가가 가능하기 때문에 컬렉션에 중복된 데이터가 저장이 가능합니다. 데이터 업데이트시 중복되어 저장되어있는 데이터를 똑같이 관리(업데이트)해 주어야 합니다.

> 참고 링크
- https://kimsangyeon.github.io/sql/nosql/database/2019/08/16/rdbms-nosql.html
- https://siyoon210.tistory.com/130

![](https://github.com/conquerex/OneHundredMillionSalary/blob/master/3_NWandDB/image_nw_8.png?raw=true)

<br>

### SQL Injection은 무엇인가요?

SQL Injection 이란 Web hacking 기법 중 하나이다. 웹 애플리케이션의 뒷단에 있는 **Database에 질의(쿼리를 보내는 것)하는 과정 사이에 일반적인 값 외에 악의적인 의도를 갖는 구문을 삽입하여 공격자가 원하는 SQL 쿼리문을 실행하는 기법**이다. 주로 사용자가 입력한 데이터를 제대로 필터링, 이스케이핑 하지 못했을 경우에 발생한다. 요즘의 거의 모든 데이터베이스 엔진은 유저 입력이 의도치 않은 동작을 하는 것을 방지하기 위해 escape 함수와 prepared statement를 제공한다.

SQL Injection 공격의 종류에는 크게 세 가지 유형이 있다.

1. 인증 우회 (AB : Auth Bypass)
2. 데이터 노출 (DD : Data Disclosure)
3. 원격명령 실행 (RCE : Remote Command Excute)

대응방안

1. 입력 값에 대한 검증
2. Prepared Statement 구문사용
3. Error Message 노출 금지
4. 웹 방화벽 사용

> 참고 링크
- https://noirstar.tistory.com/264
- https://mrrootable.tistory.com/25

<br>

### 안드로이드에서 DB 역할을 하는 것을 설명하시오.

**SQLite**

SQLite(www.sqlite.org)는 서버 단위에서 대용량 데이터를 처리하기 위한 용도보다는, 단일 응용 프로그램에서 비교적 적은 용량의 데이터를 처리하는데 적합한 데이터베이스 관리 시스템(DBMS)입니다. 즉, 안드로이드 앱과 같은 소규모의 프로그램에서 데이터베이스 관리가 필요한 경우 사용하기 적합한 데이터베이스 관리 시스템이죠.

SQLite를 사용하기 위해서 별도의 복잡한 시스템, 서비스, 프로그램이 요구되지 않습니다. 단지 SQLite를 위한 API 함수를 호출하는 것만으로 데이터베이스를 위한 기능을 사용할 수 있으며, 데이터베이스 API를 통해 관리되는 모든 데이터는 하나의 파일에 저장됩니다. (그래서 SQLite의 데이터베이스를 백업하는 작업은 하나의 데이터베이스 저장 파일을 복사하는 것으로 끝납니다.)

**Realm**

Realm 데이터베이스는 모바일에 최적화된 로컬 데이터베이스 라이브러리이다. 쿼리문을 사용해 테이블의 컬럼에 값을 저장하는 SQLite와 달리, 데이터를 객체의 형태로 저장한다는 특징을 가지고 있다.

오해하지 말아야 할 점은 Realm이 ORM(Object-relational mapping)과 다르다는 사실이다. ORM은 객체와 데이터베이스의 테이블 사이에서 중간다리로 데이터를 매핑하는 역할을 한다. 본래 객체의 데이터를 데이터베이스에 저장하려면 쿼리문을 사용해야 하는데, 네이티브 코드에서 이를 사용하기란 번거롭기 때문이다.

하지만 Realm은 데이터 컨테이너 모델을 사용해 객체를 직접 데이터베이스에 저장한다. 데이터를 중간에 변환할 필요가 없기 때문에 ORM을 사용할 필요 또한 없다는 뜻이다. 그리고 이러한 특징 덕분에 빠른 저장 및 불러오기가 가능하다.

- Realm의 장점
  - 성능이 좋고 모바일에 최적화되어있다.
  - 즉 속도가 빠르고 사용하기 편하다라는
  - 커뮤니티가 활발하고, 자료가 많다.
  - 버전이 빠르게 업데이트 되며 단점이 빠르게 개선된다.
- Realm의 단점
  - 모델 클래스를 상속할 수 없다.
  - 멀티 스레딩을 하기 까다롭다.

**Room**

ROOM은 ORM(Object Relational Mapping) 라이브러리입니다. 쉽게 말해 ROOM은 데이터베이스의 객체를 자바 or 코틀린 객체로 매핑해주는것 입니다. ROOM은 SQLite의 추상레이어 위에 제공하고 있으며 SQLite의 모든 기능을 제공하면서 편한 데이터베이스의 접근을 허용합니다.

**ROOM과 SQLite의 차이점**
1. SQLite 경우 쿼리에 대한 에러를 컴파일에 확인하는것이 없지만 ROOM에서는 컴파일 도중 SQL에 대한 유효성을 검사 가능합니다
2. Schema가 변경이 될경우 SQL쿼리를 수동으로 업데이트 해야하지만 ROOM의 경우는 쉽게 해결이 가능합니다.
3. SQLite 경우 Java데이터 객체를 변경하기위해 많은 상용구 코드(Boiler Plate code)를 사용해야하지만 ROOM의 경우 ORM라이브러리가 상용구 코드 없이 매핑 가능합니다. (※ boilerPlateCode : 수정하지 않거나 최소한의 수정만을 거쳐 여러곳에 필수적으로 사용되는 코드)
4. ROOM의 경우 LiveData와 RxJava를 위한 Observation으로 생성하여 동작할 수 있지만 SQLite는 그렇지 않습니다.

**ORM이란**

Object Relational Mapping으로 데이터베이스와 객체 지향 프로그래밍 언어간의 호환되지 않는 데이터를 변환하는 프로그래밍 기법으로 DB 테이블과 매핑되는 객체를 만들고 그 객체에서 DB를 관리하는 것이다.

>참고 링크
- https://recipes4dev.tistory.com/118
- https://d2.naver.com/helloworld/472196
- https://blog.dramancompany.com/2016/03/realm-%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4/
- https://namget.tistory.com/entry/%EC%95%88%EB%93%9C%EB%A1%9C%EC%9D%B4%EB%93%9C-ROOM-%EB%9D%BC%EC%9D%B4%EB%B8%8C%EB%9F%AC%EB%A6%AC-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0-%EC%BD%94%EB%A3%A8%ED%8B%B4

<br>

### Realm을 설명하시오.

>참고 링크
- https://realm.io/kr/products/realm-database
- https://realm.io/kr/docs/
